# AI Kernel — التصور المُحدّث (Agent لغوي + تنفيذ حقيقي)

## 1. التعريف المختصر

**AI Kernel** هو عميل ذكاء اصطناعي يعمل كلُغـة قبل أي شيء، ويتصرّف كـ **Agent تنفيذي** عند الطلب.

* تتعامل معه بالكتابة كما تتعامل مع نموذج لغوي.
* لكنه يمتلك ذراع تنفيذ حقيقي: يحلل، يولّد تغييرات، يختبر، ويطبّق.
* يعمل تلقائيًا عند بدء الجلسة، ويمكن إيقافه أو إعادة توجيهه لغويًا في أي لحظة.

> **الخلاصة:** هو Chat… لكن ما يُقال فيه يحدث فعليًا.

---

## 2. لماذا هذا المفهوم؟

المشكلة التي يحلّها AI Kernel ليست نقص الذكاء، بل **فجوة التنفيذ**:

* النماذج اللغوية تفهم وتشرح وتقترح.
* أدوات التطوير تنفّذ لكنها لا تفهم النية.

**AI Kernel** يسد الفجوة:

* يفهم النية لغويًا.
* يترجمها إلى خطة تنفيذ.
* يطبّقها تلقائيًا.

بدون واجهات معقّدة، وبدون تحويل المستخدم إلى مدير نظام.

---

## 3. مبدأ التشغيل الأساسي

لا يوجد «تشغيل ذاتي غامض» ولا مهام تبدأ من تلقاء نفسها.

يوجد فقط:

1. **أمر لغوي واضح منك**
2. **تنفيذ تلقائي كامل خلفه**

الـ Agent لا يبدأ إلا عندما تقول له ابدأ، ولا يستمر إلا ما دمت تسمح.

---

## 4. واجهة المستخدم (UX)

واجهة واحدة فقط:

* مربع كتابة (Chat)
* سجل ردود

لا Tabs، لا Boards، لا Panels.

كل التحكم يتم **لغويًا**.

---

## 5. الأوامر اللغوية (Mode B)

اللغة طبيعية + كلمات مفتاحية خفيفة تبدأ بـ `@`.

### 5.1 أوامر التشغيل

* `@start` — بدء عمل الـ Agent
* `@stop` — إيقاف فوري + rollback لآخر نقطة آمنة
* `@pause` — إيقاف عند أقرب نقطة آمنة
* `@resume` — استئناف

### 5.2 أوامر التوجيه (Plan Override لغوي)

* `@focus <نص>` — إعادة توجيه الهدف
* `@avoid <نص>` — استبعاد مسار/مجلد/نوع تغييرات
* `@limit <نص>` — وضع قيود (مثل: لا refactor كبير)

### 5.3 أوامر التحكم بالنتائج

* `@undo` — تراجع عن آخر تطبيق
* `@undo all` — تراجع عن الجلسة كاملة
* `@status` — ماذا يفعل الآن؟
* `@summary` — ملخص ما تم تطبيقه

> كل أمر يؤثّر على **القادم فقط** ولا يعيد كتابة الماضي إلا إذا طلبت ذلك صراحة.

---

## 6. دورة عمل الـ Agent (داخليًا)

الدورة كاملة غير مرئية للمستخدم:

```
Observe → Plan → Generate → Test → Apply → Checkpoint → Repeat
```

* **Observe:** فهم الحالة الحالية للنظام.
* **Plan:** بناء خطة patches وفق الهدف والقيود الحالية.
* **Generate:** توليد patch فعلي (diff).
* **Test:** تشغيل الاختبارات ذات الصلة.
* **Apply:** تطبيق التغيير تلقائيًا عند النجاح.
* **Checkpoint:** حفظ نقطة آمنة للرجوع.

هذه الدورة تتكرر تلقائيًا حتى:

* انتهاء الخطة، أو
* صدور أمر منك.

---

## 7. التنفيذ التلقائي (Auto-Apply)

عند بدء الجلسة:

* الـ Agent لا يطلب موافقة على كل خطوة.
* كل Patch يُطبّق تلقائيًا إذا نجح اختباره.
* أي فشل يؤدي إلى تجاهل patch أو rollback.

أنت وافقت مسبقًا عندما قلت `@start`.

---

## 8. الرؤية الحيّة لما يحدث

أثناء العمل، ترى رسائل مختصرة:

* "Applied patch: Parallelize orchestrator (+12%)"
* "Tests passed: 98/98"
* "Skipped patch: test failure"

ويمكنك في أي لحظة أن تسأل:

* `@status`
* `@summary`

بدون إغراق بالتفاصيل.

---

## 9. الإيقاف، التراجع، وتصحيح المسار

### الإيقاف

* `@pause` → توقف آمن.
* `@stop` → توقف فوري + rollback.

### التراجع

* `@undo` → آخر تغيير فقط.
* `@undo all` → كل الجلسة.

### تصحيح المسار

يتم لغويًا:

```
@focus ركّز فقط على orchestrator.js
@avoid أي تغييرات هيكلية
```

والـ Agent يكمّل فورًا وفق التوجيه الجديد.

---

## 10. دور المجلس (Council)

المجلس موجود لكنه **غير مرئي**:

* عدة نماذج تفكر بطرق مختلفة.
* لا يظهر للمستخدم من قال ماذا.
* لا يحتاج المستخدم لإدارته.

وظيفته الوحيدة:

> تحسين جودة القرار والتنفيذ داخليًا.

---

## 11. كيف يتعلّم AI Kernel؟

يتعلم من **سلوكك**:

* ما الذي سمحت له بتطبيقه.
* ما الذي أوقفته.
* ما الذي عدّلت مساره عنه.

هذا التعلم يُحسّن التخطيط القادم دون أن يغيّر طريقة تعاملك معه.

---

## 12. ما الذي ليس AI Kernel

* ليس IDE
* ليس لوحة تحكم
* ليس CI/CD بديل
* ليس نظام برمجة بواجهات

هو:

> Agent لغوي تنفيذي

---

## 13. الجملة النهائية

> **AI Kernel هو نموذج لغوي يتصرف كـ Agent،
> ويعمل تلقائيًا عندما تكتب،
> ويتوقف فورًا عندما تطلب.**

هذا هو المفهوم النهائي، المتوازن، والعملي.
